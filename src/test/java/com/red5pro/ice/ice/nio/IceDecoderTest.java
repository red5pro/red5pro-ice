package com.red5pro.ice.ice.nio;

import static org.junit.Assert.*;

import java.util.LinkedList;
import java.util.List;

import org.apache.mina.core.buffer.IoBuffer;
import com.red5pro.ice.ice.nio.IceDecoder.FrameChunk;
import com.red5pro.ice.stack.RawMessage;
import com.red5pro.ice.util.Utils;
import org.junit.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class IceDecoderTest {

    private static final Logger logger = LoggerFactory.getLogger(IceDecoderTest.class);

    /**
     * Thread local for incomplete frame chunks.
     */
    private ThreadLocal<FrameChunk> tcpFrameChunk = new ThreadLocal<>();

    @Test
    public void test() {
        // caused buffer overflow ex in icedecoder
        logger.info("\nOverflow");
        IoBuffer in = IoBuffer
                .wrap(Utils
                        .fromHexString("009C806F5C1C1F223F6B8F902F051D705A99600ADDD773734D852F916F7694687C561691634154DCB8BB04F424EA7BAE9391E3CA77BB55357B22DB04A49190E8D88E6F9F489A3DE32DD92C328505E2B693FA148B94C7039F00CB4D0154A810DBF40846449DE44DED8C702FE639A32A964EEDBFD9389170FD2ED067A68E424CD6696D3FFB6CAD89D6177251943E2612C33A62C222D096C742176A72FA15B7049F906469C9E3F63B0926261068BEDE0001120004922994905C48324531F3E33305502F31FC960D89D712AD93864E6245000E92E42EEF1D821E5985520F87DDE857C2BD11DD3A7F333B757B53F4D51BF77341442FFBDCBE410EB8AD76094A2178C8914D7F2CFBD5560F445A0D7551080EA6FF3AD7A44A62E35199E9CE74C3086F6AE736674B398AB6722DE8D2F3713FEFD0D2A61F42BD7EB918563DEAE8CB18CB1A764E070E0C86A1DED03D24A7F7F6FCF65E75674DBED35E99A01ABC87EC6AF3826F4BAA137CEF28A8F1E2ABE2A31C6BB2040575ABA9100CC65F85C3A700B48E11F14A1968780EB68360EEF6EB653AD636D3849BDCC2403587736647133441AC096D97C68A0112AA4E83E88596958DE0F4A5550F32BA5B6D74B88703B5E02D4E10B581243166AD9165860B61C37E1A0348D045C9DDC75CC353999AB2BE51F5D2D3300F752336CB1AE492B42E0324AE49B7CB94660426BDFF4E4A1C5277C7A8A71C8F855378C625FE44C717C3A23171DA1FD1DAFB4839D8A4AC6A136CFFFAC7995409F18CC06F71440AFD50C947AC11CBD72E443BA615BD58B43DBA48B4D614A668492E8C38E1DFC6C7A19F528223CB2F673F8C89235348F2676427E1D8C94C0E9D4E4D7D03058A69D491AB440DB77A26C1DB4B2DAE208A6B5ED28B5B4A30078C16C87F131A86EFD704F9452B11E261317DE508E239D71BD7D4A968600403C39541036B3441D2C0F1223838783C5CE151F2F81BCC6792C56BD7ECF533D9E59D2DB2E8963439ADA6CD5E93083FB2655FA6B2EBE5A22314CF30D6E372EDB5CA186C2AE23CE7FAC1793CA91CE0F4977B5ED5813ECF35B9DFF8C30630368444B796996AF1F2AD0D29BAE8DF6198693DE903DF0A8BA86A9C21FB23CBF31B25CF928B0199A97B6A01894848825950E1C0ECDE99BC9C3F7B3ED70872CE2EC2A1A952A1ABF5F3681DB1579E103006D4EC99ECC9791760A1BFDF1B3F92878FADE13A2620B4CA941CF3DD0597033C8EECC62A347FB19A61896373E5C4347DBCBA9D2DA457367D99DC7709AFECFAF41DC6ED65A100A8B349C512D21CA1C93F545CC20A2527D0B1F6C578C077C5698D70B5E5552CA00C75BF95E827102C806D4F36C22214D79A5A0B19007E2E161B8223CFBF3F6656D0A2435095D8A24478DB7065875A88BE440A03B4D9176ECDF2A5E754DEA86220183DE18C325184B1BCDDE362D7DD13CAD183F0AB35BD05D1D349535821EB4FC5A1CDDBC5343C0DA688AE1A423578A0DF7461279A053355DC64EAA171AB3F8EC736CAB3913930FF44F199AC3EE551CC159A8B75177E3C824F0FAC5AB5C6CFDE4FC02827EF726FDFCDE15B59541E09B4714744FB4C3F830DAAB63ED16AF691AAC6962B5470C39DFEF167E59A5DD662CEF47CDE6D0A3368AD38DB85275D8B8780BAC1BF20EDA0D8934A063440479EAD6BD701216285335CCBC512D14FD5F38BE31F48F9393109867DB5D3C2CB6CA8FE0E893F4665AFACA1571DDA319D2F4BE198ACB380AAC12D9E0029B6539FD14CA7EFD5E4620F63C61E57A8C4B163DD2ECFE6D3391A10DF2811ACD4D43FFA77CE7468AF1811C58945E989472C1982824B647953F0DAB0759DEA9BA3B4726F014B948B70E17A9FFF2D02CBD0897013E000B2B70B2FF73577B2FBB42BB74E38AB1F26BCC07F"));
        List<RawMessage> messages = decode(in);
        logger.info("Message count: {}", messages.size());
        assertTrue(messages.size() == 2);
        assertNull(tcpFrameChunk.get());
        tcpFrameChunk.set(null);
        messages.clear();
        // 2 chunks with a frame size at the end
        logger.info("\nTwoMessage with size suffix");
        in = IoBuffer
                .wrap(Utils
                        .fromHexString("002F90640522DD0B179DF378D057BEDE0001120002D0C9914B6EFA818DE8E83CC67895592618E4F61FC408BB4922511967049690640523DD0B179DF378D057BEDE0001120002D0119972BEDFD14022B5CE3C2C1D98E2C304A4FA18ED3C5CA50D2CC43DD593629A2A6F5222F697A3E66E6EAA74D7CB6F01B8F755C291F49CF74749087857D0A33C93DBD920A6E0F8EC2B7A78100F135388FC8CDD0E4134617F49E0C7D4C805581DFF9F187785B5EF9A6928A7A019A113D571A2B9A9CE7FAC05DC85D44B493256AED8FA713903C452672C0720E32E1F0FC48B962CBC009252B27449A48A208D4D6DDB89FF03A88A75AB8DCEE4615EEDF819E9797E43494D6A48D400C1F664E787A17343F355547472613ACC607456B76B564E365CF20D3E26447432C669E2DD39E8CB91FB1504B4CA67833564E16DA6CA2181479BAF1A4F83A83C25C04F0989E411B19A5FE6E1AD65ECFA08A895B3DC217EF0215F7E4FE8B711544EC8ED0DD785111DA4B5C1117F7235049A4B2360091CDD77634808CF82B2B09558B9E8317A470C9586FA5A55DCB147A56281B132D9D605CCA7665F30A72BDF3CB53A40F0A0F497635A77705F339DD2ED2474E741B9C4C965377AD9C6DF4F9ABF9D74B721FDD47863D2F23C7BE992F8E334FD12DFFF60B8E8DCA9979E77D853ED3BED4C2037EC1585113781F089CE89A925BA55DA3FFEB7655BD8E80AAF11127A54BA68EEAAAA8BB0CD4D7570C4C4DE68358ADC81EA932C24840495D2A854196B489ED69D5DBB9C833EA623DE23FF077F756FB33D0CA9C06CA2A1C6C5C81F6B5967EA5A570775EA87B461C4176592A71A74449450985B893EFFF532A50485AD42EAF2DFB08CD7536DDE82B9FD3F58F97C5F3DC6A8DC42F32A76A8EE0BD3C9F0A1807CB74E9D38FD59663C04445E7009298AB0C48A5B84679E4EF641218A93D322B3DA4F143B99EDF76FB3CA9D3C72BE4B1B41E2A5281D37BF1133132427ECDC28770253315FB848C090231F95D1577DAC44A887314F6D780B3FAFEDB121F3E10769E691E3E86A1E50C1C0E60825A05D175E2CD84EFDE58CBACAD70B406D6084B2592DACCF8B83394E7B1180BBCB9FA628358B0A7F792A10F893E2CB423B4D1732C4E9253A6D9B7AB39638C0F65E432304AA57B06BCBFD09B6A2C0FD47166A39CA55AD363878F4CE89C1FF8170D597F07A74DFE3DA24D3A6C5C7DB220753376BDB116DFA1F86B6787450B59298348C230F90991F8E54379F49A1A5CF5BA13C3DB9094858123F6C63EB202C87055DD752681A3B77AA626792B8EFE8E5BCFE2C740B052AD8C804594308C715BA128CEC4FB247CF1B9D2EDDAB5CB578119819A15A7EAC270EA0BA036E21252E7608F5EFD8C58C4E343D15F9DE26B004F4FA9418A4BB262C25910107DE07272E102A20DABC99ED3301CDB68217D755A40D67046872974F8ED21379811E64E2B4F930A1FCC45FC10060290F78462D4C7D637FB00506F209DDC49D364315E5BE900888D998674FF5EDDEDDEABB1D8205BB56757848E9E0318A723745FB6996EC6751D1FF71D0FB3BB810EB5E0DD897CD0E858D7A099BDAB88FAD4258A0795D578ADCE792E267CF1031D7FB4C7BC4E6D6D20357089DD58B01C699B016109CDE50450743C048A6C3BAC281CC06F6E7DD6A54E7CEBFAC4F67E269529E429EA5C8E431362C1D31009DA501E1B161173364BEE128D9EB46E01F81E47F28FC66899A93000A"));
        messages = decode(in);
        logger.info("Message count: {}", messages.size());
        assertTrue(messages.size() == 2);
        assertNotNull(tcpFrameChunk.get());
        tcpFrameChunk.set(null);
        messages.clear();
        // caused underflow
        logger.info("\nUnderflow");
        in = IoBuffer
                .wrap(Utils
                        .fromHexString("009C806F4FFE135D289C3116207926EE0505396750DAEF39C9E8D0412658AD333686BDE79BE355F8052B7017DD4DBF05F52B5ED1B38505186C0A02DAD4F7B5AAB808F21DB7ED8A8273285B757796D122929C714ADD566375B1EA256F6B1ABA8FC329CFAFE4760E4194D10CC50C345E5E2891C074DEEF139A45841498BB35994AC25ADD10DF5925F1AA26DBA44C9664D8353EAFAF122658106267CC7C131C035E90E41E4F965A680C67FEE6B2BEDE0001120003DE8F77D28F7C004DF199DA1696D109DB727A8A1B65D10DFA7A3DDB312C81A845E2803226C2FD3549B29EC975EAA6DCEFF926522970976EE9693A1620B70431E6F2FCF9FF40D38273A0EE0430065CD53CD01245622A1D3BC70817BF472837C7714F0940497755D311B78F1CE38F2F25DC299467D72279114C1DE9879228AA59E8D6D4AC90014A8547056A745461DACC87628279F04E289EBB9C0AEA18869676CAFA9B2460C412F5F8589005BD76661CBDDDA4BB1975C85C7483607E838ACFADA7C1DA150A37D37F6351395BD09EA11C288751C49C4A86D13E4BAADE1382BA1F3CD236F09D54463DB5E79CA689CC08139D1C4C13530277E7A0C570473BC68AFF15BCA6718CDADC8648C86AFB9D0A1C6819573637AC6A9E1D92E32A0908E62ED056E23297ECB398286596D13EFD69E9E4382E3DCE82F45648945C9BABD5728E3291FB64F4C26BE1986D1F2FB7BE3BF0EE54DAB410EADE0381D4AE2FADE7C2F148F92AE0E9EEECA8ECB424861B62FAE528CDB834DAE14C95F6EF92C06C659CF7BF73727DC5B593603E2D82011337B8EFEA62942B84A7495A9E2BB5B804F900A7E0829406AD2E578137D71A78F91AEB18B4C3D3BBF6E2F1EA7977DA3D41C1A6870BFB91546543D8063E6E40A16F50FB46733A19E551805FDE88DAAC8473B9408CA21C600FD660FD98C00487D6AFA11DF32064EE59BD8038EFDF46661E46056FBEE9DF69AD75A7D1917A466BCC84A66141E5F9A8936A42521793F5074DB9613FB76EB9E1611096347E0B95B43FED163A5FB88D9DEA9946E7AF6579BE55915C2FAD4388A5B75316000FD1986F7167E5ACEE77012DE43A0D492C85D490902560BEF75046423C3D5ACC9C4F259290867AE14F4429D121EBA92F31E44DF65707E2C7E0CA352F3B37AFAAFF203EF8BD7C9FC2186471A97A6F3A50BFFA9AFF0DE8304C3F02897CC3661E98D228608363B6E46272DF0ED04443ED3DEBE46C5E04D6DC28175B5DCE7C1848E9C54E2B50EABF87138ADAD2D64EA6C6CF4B3BF31D56A77664D7CA5D295DA0ACE958DA32E4D05E0412E3BFEA02E02DF1237C05FB49DD3CE16E9209F12B83DEAC4545E85A2441D0985F02BFB37704B593B3A4367A26AB2CE5BE3B80CD1A22F49502714823339483144092F22E76346DD05F6DAED380E05E39C5928A2038AB7972D43179142D"));
        messages = decode(in);
        logger.info("Message count: {}", messages.size());
        assertTrue(messages.size() == 1);
        assertNotNull(tcpFrameChunk.get());
        tcpFrameChunk.set(null);
        messages.clear();
    }

    /*
     * Incoming webrtc packets in udp contain only one message, in tcp they may come in as a whole, fragments, or any combo of the two as well as multiple messages.
     */
    List<RawMessage> decode(IoBuffer in) {
        List<RawMessage> messages = new LinkedList<>();
        IceDecoder decoder = new IceDecoder();
        // get the incoming bytes
        byte[] buf = null;
        // TCP has a 2b prefix containing its size per RFC4571 formatted frame, UDP is simply the incoming data size so we start with that
        int frameLength = in.remaining();
        // if we're tcp handle chunks etc
        // loop reading input until no usable bytes remain
        checkFrameComplete: do {
            // check for an existing frame chunk first
            FrameChunk frameChunk = tcpFrameChunk.get();
            if (frameChunk != null) {
                // check for completed
                if (frameChunk.isComplete()) {
                    // flip for reading
                    frameChunk.chunk.flip();
                    // size buf for reading all the frame chunk data
                    buf = new byte[frameChunk.totalLength];
                    // get the frame
                    frameChunk.chunk.get(buf);
                    // now clear / reset
                    frameChunk.reset();
                    // clear thread local
                    tcpFrameChunk.set(null);
                    // send a buffer of bytes for further processing / handling
                    messages.add(RawMessage.build(buf, null, null));
                    // no more frame chunks, so regular processing will proceed
                    continue checkFrameComplete;
                } else {
                    // add to an existing incomplete frame
                    int remaining = in.remaining();
                    logger.trace("Add to an existing incomplete frame, remaining: {} chunk remaining: {}", remaining, frameChunk.chunk.remaining());
                    buf = new byte[Math.min(remaining, frameChunk.chunk.remaining())];
                    in.get(buf);
                    frameChunk.chunk.put(buf);
                    // restart at the top of the loop checking to see if the frame is now complete and proceed appropriately
                    logger.debug("Existing frame chunk was appended, complete? {} in remaining: {}", frameChunk.isComplete(), in.remaining());
                    // nothing should remain in the input at this point
                    continue checkFrameComplete;
                }
            } else {
                // no frame chunks, handle input
                int remaining = in.remaining();
                // we need at least 2 bytes for the frame length
                if (remaining > 1) {
                    // get the frame length
                    frameLength = ((in.get() & 0xFF) << 8) | (in.get() & 0xFF);
                    logger.trace("Frame length: {}", frameLength);
                    // update remaining (since we just grabbed 2 bytes)
                    remaining -= 2;
                    // if the frame length is greater than the remaining bytes, we'll have to buffer them until we get the full frame
                    if (remaining < frameLength) {
                        tcpFrameChunk.set(decoder.new FrameChunk(frameLength, in));
                    } else {
                        // read as much as we have
                        buf = new byte[frameLength];
                        // get the bytes into our buffer
                        in.get(buf);
                        // send a buffer of bytes for further processing / handling
                        messages.add(RawMessage.build(buf, null, null));
                    }
                } else {
                    logger.warn("Not enough bytes to get the frame length");
                    in.clear();
                    break;
                }
            }
        } while (in.hasRemaining());
        logger.trace("All TCP input data decoded");
        return messages;
    }

}
